import { ButtonStyle, EmbedBuilder, ActionRowBuilder, normalizeArray, ButtonBuilder, BaseInteraction, Message, ComponentType, MessageComponentInteraction } from 'discord.js';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var defaultOptions = {
  firstEmoji: "\u23EA",
  prevEmoji: "\u25C0\uFE0F",
  nextEmoji: "\u25B6\uFE0F",
  lastEmoji: "\u23ED",
  firstLabel: "",
  prevLabel: "",
  nextLabel: "",
  lastLabel: "",
  limit: 5,
  idle: 5 * 60 * 1e3,
  ephemeral: false,
  prevDescription: "",
  postDescription: "",
  attachments: [],
  contents: [],
  buttonStyle: ButtonStyle.Secondary,
  loop: false
};

// src/lib/types/Options.ts
var ExtraRowPosition = /* @__PURE__ */ ((ExtraRowPosition2) => {
  ExtraRowPosition2[ExtraRowPosition2["Above"] = 0] = "Above";
  ExtraRowPosition2[ExtraRowPosition2["Below"] = 1] = "Below";
  return ExtraRowPosition2;
})(ExtraRowPosition || {});

// src/lib/pagination/PaginationEmbed.ts
var PaginationEmbed = class extends EmbedBuilder {
  constructor(options = {}) {
    super();
    __publicField(this, "buttonInfo");
    __publicField(this, "images");
    __publicField(this, "descriptions");
    __publicField(this, "actionRows");
    __publicField(this, "totalEntry");
    __publicField(this, "totalPages");
    __publicField(this, "currentPage");
    __publicField(this, "limit");
    __publicField(this, "idle");
    __publicField(this, "ephemeral");
    __publicField(this, "prevDescription");
    __publicField(this, "postDescription");
    __publicField(this, "loop");
    __publicField(this, "embeds");
    __publicField(this, "attachments");
    __publicField(this, "fieldPaginate");
    __publicField(this, "buttons");
    __publicField(this, "contents");
    __publicField(this, "payload");
    __publicField(this, "customFooter");
    __publicField(this, "mainActionRow");
    __publicField(this, "rawFields");
    __publicField(this, "extraRows");
    __publicField(this, "rawFooter");
    __publicField(this, "changedButtons");
    const mergedOptions = { ...defaultOptions, ...options };
    this.buttonInfo = {
      first: {
        emoji: mergedOptions.firstEmoji,
        label: mergedOptions.firstLabel,
        style: mergedOptions.buttonStyle
      },
      prev: {
        emoji: mergedOptions.prevEmoji,
        label: mergedOptions.prevLabel,
        style: mergedOptions.buttonStyle
      },
      next: {
        emoji: mergedOptions.nextEmoji,
        label: mergedOptions.nextLabel,
        style: mergedOptions.buttonStyle
      },
      last: {
        emoji: mergedOptions.lastEmoji,
        label: mergedOptions.lastLabel,
        style: mergedOptions.buttonStyle
      }
    };
    this.images = [];
    this.descriptions = [];
    this.embeds = [];
    this.actionRows = [];
    this.payload = {};
    this.totalEntry = 0;
    this.totalPages = 0;
    this.currentPage = 1;
    this.customFooter = true;
    this.rawFields = [];
    this.mainActionRow = new ActionRowBuilder();
    this.extraRows = [];
    this.setOptions(mergedOptions);
  }
  addFields(...fields) {
    this.rawFields.push(...normalizeArray(fields));
    return this;
  }
  spliceFields(index, deleteCount, ...fields) {
    if (this.data.fields)
      this.data.fields.splice(index, deleteCount, ...fields);
    else
      this.data.fields = fields;
    return this;
  }
  setFields(...fields) {
    this.rawFields = normalizeArray(fields);
    return this;
  }
  setOptions(options) {
    this.setEmojis({
      firstEmoji: options.firstEmoji,
      prevEmoji: options.prevEmoji,
      nextEmoji: options.nextEmoji,
      lastEmoji: options.lastEmoji
    });
    if (options.buttonStyle)
      this.setStyle(options.buttonStyle);
    this.setLabels({
      firstLabel: options.firstLabel,
      prevLabel: options.prevLabel,
      nextLabel: options.nextLabel,
      lastLabel: options.lastLabel
    });
    this.limit = options.limit ?? this.limit;
    this.idle = options.idle ?? this.idle;
    this.ephemeral = options.ephemeral ?? this.ephemeral;
    this.loop = options.loop ?? this.loop;
    this.prevDescription = typeof options.prevDescription === "string" ? options.prevDescription : this.prevDescription;
    this.postDescription = typeof options.postDescription === "string" ? options.postDescription : this.postDescription;
    this.attachments = options.attachments ?? this.attachments;
    this.contents = options.contents ?? this.contents;
    this.setButtons();
    return this;
  }
  setImages(...images) {
    this.images = normalizeArray(images);
    return this;
  }
  addImages(...images) {
    this.images.push(...normalizeArray(images));
    return this;
  }
  setDescriptions(...descriptions) {
    this.descriptions = normalizeArray(descriptions);
    return this;
  }
  addDescriptions(...descriptions) {
    this.descriptions.push(...normalizeArray(descriptions));
    return this;
  }
  setEmbeds(embeds, template) {
    if (template) {
      embeds = embeds.map((embed, index, array) => template(embed instanceof EmbedBuilder ? embed : EmbedBuilder.from(embed), index, array));
    }
    this.embeds = embeds;
    this.limit = 1;
    return this;
  }
  addEmbeds(embeds, template) {
    if (template) {
      embeds = embeds.map((embed) => template(EmbedBuilder.from(embed)));
    }
    this.embeds.push(...embeds);
    return this;
  }
  paginateFields(paginate = true) {
    this.fieldPaginate = paginate;
    return this;
  }
  setIdle(idle) {
    this.idle = idle;
    return this;
  }
  setEphemeral(ephemeral = true) {
    this.ephemeral = ephemeral;
    return this;
  }
  setLimit(limit) {
    this.limit = limit;
    return this;
  }
  setPrevDescription(prevDescription) {
    this.prevDescription = prevDescription;
    return this;
  }
  setPostDescription(postDescription) {
    this.postDescription = postDescription;
    return this;
  }
  setEmojis(emojiOptions) {
    this.buttonInfo.first.emoji = emojiOptions.firstEmoji ?? this.buttonInfo.first.emoji;
    this.buttonInfo.prev.emoji = emojiOptions.prevEmoji ?? this.buttonInfo.prev.emoji;
    this.buttonInfo.next.emoji = emojiOptions.nextEmoji ?? this.buttonInfo.next.emoji;
    this.buttonInfo.last.emoji = emojiOptions.lastEmoji ?? this.buttonInfo.last.emoji;
    return this;
  }
  setLabels(labelOptions) {
    this.buttonInfo.first.label = labelOptions.firstLabel ?? this.buttonInfo.first.label;
    this.buttonInfo.prev.label = labelOptions.prevLabel ?? this.buttonInfo.prev.label;
    this.buttonInfo.next.label = labelOptions.nextLabel ?? this.buttonInfo.next.label;
    this.buttonInfo.last.label = labelOptions.lastLabel ?? this.buttonInfo.last.label;
    return this;
  }
  setStyle(style) {
    this.buttonInfo.first.style = style;
    this.buttonInfo.prev.style = style;
    this.buttonInfo.next.style = style;
    this.buttonInfo.last.style = style;
    return this;
  }
  setButtonAppearance(options) {
    const { first, prev, next, last } = options;
    this.buttonInfo.first.label = first.label ?? this.buttonInfo.first.label;
    this.buttonInfo.prev.label = prev.label ?? this.buttonInfo.prev.label;
    this.buttonInfo.next.label = next.label ?? this.buttonInfo.next.label;
    this.buttonInfo.last.label = last.label ?? this.buttonInfo.last.label;
    this.buttonInfo.first.emoji = first.emoji ?? this.buttonInfo.first.emoji;
    this.buttonInfo.prev.emoji = prev.emoji ?? this.buttonInfo.prev.emoji;
    this.buttonInfo.next.emoji = next.emoji ?? this.buttonInfo.next.emoji;
    this.buttonInfo.last.emoji = last.emoji ?? this.buttonInfo.last.emoji;
    this.buttonInfo.first.style = first.style ?? this.buttonInfo.first.style;
    this.buttonInfo.prev.style = prev.style ?? this.buttonInfo.prev.style;
    this.buttonInfo.next.style = next.style ?? this.buttonInfo.next.style;
    this.buttonInfo.last.style = last.style ?? this.buttonInfo.last.style;
    return this;
  }
  setButtons(buttons) {
    if (buttons)
      this.changedButtons = true;
    this.buttons = buttons ?? {
      first: new ButtonBuilder().setCustomId("paginate-first"),
      prev: new ButtonBuilder().setCustomId("paginate-prev"),
      next: new ButtonBuilder().setCustomId("paginate-next"),
      last: new ButtonBuilder().setCustomId("paginate-last")
    };
    return this;
  }
  addActionRows(actionRows, position = 1 /* Below */) {
    this.extraRows.push({
      rows: actionRows,
      position
    });
    return this;
  }
  setAttachments(attachments) {
    this.attachments = attachments;
    return this;
  }
  addAttachment(attachment) {
    this.attachments.push(attachment);
    return this;
  }
  addAttachments(attachments) {
    this.attachments.push(...attachments);
    return this;
  }
  goToPage(pageNumber) {
    if (pageNumber < 1)
      pageNumber = this.totalPages;
    if (pageNumber > this.totalPages)
      pageNumber = 1;
    this.currentPage = pageNumber;
    if (this.embeds.length) {
      const embed = this.embeds[this.currentPage - 1];
      this.payload.embeds = [EmbedBuilder.from(embed)];
      return this;
    }
    if (!this.data.footer) {
      this.customFooter = false;
      this.rawFooter = "Pages: {pageNumber}/{totalPages}";
    } else if (this.customFooter && !this.rawFooter) {
      this.rawFooter = this.data.footer.text;
    }
    this.setFooter({
      text: this.rawFooter.replace(/{pageNumber}/g, `${pageNumber}`).replace(/{totalPages}/g, `${this.totalPages}`),
      iconURL: this.data.footer?.icon_url
    });
    if (this.images.length) {
      this.setImage(this.images[pageNumber - 1]);
    }
    this.payload.content = (Array.isArray(this.contents) ? this.contents[this.currentPage - 1] : this.contents) ?? void 0;
    if (this.descriptions.length) {
      this.setDescription(
        `${this.prevDescription}
${this.descriptions.slice(pageNumber * this.limit - this.limit, pageNumber * this.limit).join("\n")}
${this.postDescription}`
      );
    }
    if (this.fieldPaginate) {
      super.setFields(this.rawFields.slice(pageNumber * this.limit - this.limit, pageNumber * this.limit));
    }
    return this;
  }
  setContents(contents) {
    this.contents = contents;
    return this;
  }
  ready() {
    if (!this.fieldPaginate) {
      this.setFields(this.rawFields);
    }
    this.totalEntry = this.embeds.length || Math.max(this.descriptions.length, this.images.length, this.fieldPaginate ? this.rawFields.length : 0);
    this.totalPages = Math.ceil(this.totalEntry / this.limit);
    this._readyPayloads();
    this.goToPage(this.currentPage);
    return this.payload;
  }
  async goFirst(interaction) {
    this.currentPage = 1;
    if (!this.loop) {
      this.buttons.first.setDisabled();
      this.buttons.prev.setDisabled();
    }
    this.buttons.next.setDisabled(false);
    this.buttons.last.setDisabled(false);
    this.goToPage(1);
    await interaction.update(this.payload);
  }
  async goPrev(interaction) {
    this.currentPage--;
    if (!this.loop) {
      this.buttons.first.setDisabled(this.currentPage === 1);
      this.buttons.prev.setDisabled(this.currentPage === 1);
    }
    this.buttons.next.setDisabled(false);
    this.buttons.last.setDisabled(false);
    this.goToPage(this.currentPage);
    await interaction.update(this.payload);
  }
  async goNext(interaction) {
    this.currentPage++;
    this.buttons.prev.setDisabled(false);
    this.buttons.first.setDisabled(false);
    if (!this.loop) {
      this.buttons.next.setDisabled(this.currentPage === Math.ceil(this.totalEntry / this.limit));
      this.buttons.last.setDisabled(this.currentPage === Math.ceil(this.totalEntry / this.limit));
    }
    this.goToPage(this.currentPage);
    await interaction.update(this.payload);
  }
  async goLast(interaction) {
    this.currentPage = Math.ceil(this.totalEntry / this.limit);
    this.buttons.prev.setDisabled(false);
    this.buttons.first.setDisabled(false);
    if (!this.loop) {
      this.buttons.next.setDisabled();
      this.buttons.last.setDisabled();
    }
    this.goToPage(this.currentPage);
    await interaction.update(this.payload);
  }
  _readyButton(button, label, emoji, style) {
    if (label)
      button.setLabel(label);
    if (emoji)
      button.setEmoji(emoji);
    button.setStyle(style);
    return this;
  }
  _readyActionRows() {
    if (!this.changedButtons) {
      this._readyButton(this.buttons.first, this.buttonInfo.first.label, this.buttonInfo.first.emoji, this.buttonInfo.first.style);
      this._readyButton(this.buttons.prev, this.buttonInfo.prev.label, this.buttonInfo.prev.emoji, this.buttonInfo.prev.style);
      this._readyButton(this.buttons.next, this.buttonInfo.next.label, this.buttonInfo.next.emoji, this.buttonInfo.next.style);
      this._readyButton(this.buttons.last, this.buttonInfo.last.label, this.buttonInfo.last.emoji, this.buttonInfo.last.style);
    }
    this.buttons.first.setDisabled();
    this.buttons.prev.setDisabled();
    this.buttons.next.setDisabled();
    this.buttons.last.setDisabled();
    if (this.totalEntry > this.limit) {
      this.buttons.last.setDisabled(false);
      this.buttons.next.setDisabled(false);
    }
    if (this.loop && this.totalEntry > this.limit) {
      this.buttons.first.setDisabled(false);
      this.buttons.prev.setDisabled(false);
    }
    this.mainActionRow.setComponents(Object.values(this.buttons));
    this.actionRows = [this.mainActionRow];
    if (this.extraRows.length > 0) {
      for (const row of this.extraRows) {
        if (row.position === 0 /* Above */)
          this.actionRows.unshift(...row.rows);
        else
          this.actionRows.push(...row.rows);
      }
    }
    return this;
  }
  _readyPayloads() {
    this._readyActionRows();
    this.payload.ephemeral = this.ephemeral;
    this.payload.components = this.actionRows;
    this.payload.content = (Array.isArray(this.contents) ? this.contents[0] : this.contents) ?? void 0;
    const embed = this.embeds.length ? EmbedBuilder.from(this.embeds[0]) : this;
    this.payload.embeds = [embed];
    this.payload.files = this.attachments;
    return this.payload;
  }
};
__name(PaginationEmbed, "PaginationEmbed");

// src/lib/utils/util.ts
var authorOrUser = /* @__PURE__ */ __name((messageOrInteraction) => "user" in messageOrInteraction ? messageOrInteraction.user : messageOrInteraction.author, "authorOrUser");

// src/lib/pagination/Pagination.ts
var Pagination = class extends PaginationEmbed {
  constructor(messageOrInteraction, options = {}) {
    super(options);
    __publicField(this, "interaction");
    __publicField(this, "authorizedUsers");
    __publicField(this, "collector");
    if (!(messageOrInteraction instanceof BaseInteraction) && !(messageOrInteraction instanceof Message)) {
      throw new TypeError("The interaction must be an instance of Interaction or Message");
    }
    this.interaction = messageOrInteraction;
    this.authorizedUsers = [authorOrUser(messageOrInteraction).id];
  }
  setAuthorizedUsers(authorizedUsers) {
    this.authorizedUsers = authorizedUsers;
    return this;
  }
  addAuthorizedUser(authorizedUser) {
    this.authorizedUsers.push(authorizedUser);
    return this;
  }
  addAuthorizedUsers(authorizedUsers) {
    this.authorizedUsers.push(...authorizedUsers);
    return this;
  }
  paginate(message) {
    this.collector = message.createMessageComponentCollector({
      filter: ({ customId, user }) => ["first", "prev", "next", "last"].some((position) => this.buttons[position]?.data.custom_id === customId) && (this.authorizedUsers.length ? this.authorizedUsers.includes(user.id) : true),
      idle: this.idle,
      componentType: ComponentType.Button
    });
    this.collector.on("collect", (interaction) => {
      if (interaction.customId === this.buttons.first.data.custom_id) {
        return this.goFirst(interaction);
      }
      if (interaction.customId === this.buttons.prev.data.custom_id) {
        return this.goPrev(interaction);
      }
      if (interaction.customId === this.buttons.next.data.custom_id) {
        return this.goNext(interaction);
      }
      return this.goLast(interaction);
    });
    return this;
  }
  async render() {
    if (this.interaction instanceof BaseInteraction && (this.interaction.replied || this.interaction.deferred)) {
      return this.editReply();
    }
    return this.reply();
  }
  async reply() {
    const payload = this.ready();
    const message = await this.interaction.reply(payload);
    this.paginate(message);
    return message;
  }
  async followUp() {
    const payload = this.ready();
    if (!(this.interaction instanceof BaseInteraction))
      throw new TypeError("The interaction is not an instance of Interaction");
    const message = await this.interaction.followUp(payload);
    this.paginate(message);
    return message;
  }
  async editReply() {
    const payload = this.ready();
    if (!(this.interaction instanceof BaseInteraction))
      throw new TypeError("The interaction is not an instance of Interaction");
    const message = await this.interaction.editReply(payload);
    this.paginate(message);
    return message;
  }
  async update() {
    const payload = this.ready();
    if (!(this.interaction instanceof MessageComponentInteraction))
      throw new TypeError("The interaction is not an instance of MessageComponentInteraction");
    const message = await this.interaction.update(payload);
    this.paginate(message);
    return message;
  }
  async send() {
    const payload = this.ready();
    if (!this.interaction.channel)
      throw new TypeError("The interaction or message don't have a channel");
    const message = await this.interaction.channel.send(payload);
    this.paginate(message);
    return message;
  }
};
__name(Pagination, "Pagination");

export { ExtraRowPosition, Pagination, PaginationEmbed, authorOrUser };
//# sourceMappingURL=index.mjs.map